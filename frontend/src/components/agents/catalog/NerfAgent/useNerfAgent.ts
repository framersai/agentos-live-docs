// File: frontend/src/components/agents/catalog/NerfAgent/Nerf/useNerfAgent.ts
/**
 * @file useNerfAgent.ts
 * @description Composable logic for "Nerf" - the General AI Assistant.
 * @version 1.0.0
 */
import { ref, computed, watch, type Ref } from 'vue';
import { useAgentStore } from '@/store/agent.store';
import { useChatStore, type MainContent } from '@/store/chat.store';
import type { IAgentDefinition } from '@/services/agent.service';
import { voiceSettingsManager } from '@/services/voice.settings.service';
import { chatAPI, type ChatMessagePayloadFE, type ChatMessageFE } from '@/utils/api';
import type { ToastService } from '@/services/services';
import { marked } from 'marked';
import { type AdvancedHistoryConfig, DEFAULT_NERF_HISTORY_CONFIG, type NerfAgentComposable } from './NerfAgentTypes';

import { api } from '@/utils/api'; // Ensure this path is correct
export function useNerfAgent(
  agentConfigRef: Ref<IAgentDefinition>,
  toastInstance?: ToastService,
): NerfAgentComposable {
  const agentStore = useAgentStore();
  const chatStore = useChatStore();
  const toast = toastInstance;
  const agentId = computed(() => agentConfigRef.value.id);

  const isLoadingResponse = ref(false);
  const currentSystemPrompt = ref('');
  const agentDisplayName = computed(() => agentConfigRef.value?.label || "Nerf");

  const mainContentToDisplay = computed<MainContent | null>(() => chatStore.getMainContentForAgent(agentId.value));

   const fetchSystemPrompt = async () => {
      const key = agentConfigRef.value.systemPromptKey;
      if (key) {
        try {
          const response = await api.get(`/prompts/${key}.md`);
          currentSystemPrompt.value = response.data as string;
        } catch (e) {
          console.error(`[${agentDisplayName.value}] Failed to load system prompt: ${key}.md`, e);
        console.error(`[${agentDisplayName.value}] Failed to load system prompt: ${key}.md`, e);
        currentSystemPrompt.value = "You are Nerf, a friendly and concise general AI assistant. Help users with their questions efficiently.";
        toast?.add({type: 'error', title: 'Prompt Load Error', message: `Could not load instructions for ${agentDisplayName.value}.`});
        }
      } else {
      currentSystemPrompt.value = "You are Nerf, a friendly and concise general AI assistant. Help users with their questions efficiently.";
      }
    };

  const initialize = async (agentDef: IAgentDefinition) => {
    // agentConfigRef.value = agentDef; // Not needed if agentConfigRef is already reactive from props
    await fetchSystemPrompt(); // Fetch based on the agentConfigRef

    // Welcome message logic is typically handled by the View's onMounted
  };

  const cleanup = () => {
    console.log(`[${agentDisplayName.value}] Cleanup performed.`);
    // Add any specific cleanup logic for Nerf if needed
  };

  const handleNewUserInput = async (text: string) => {
    if (!text.trim() || isLoadingResponse.value) return;
    const currentAgentIdStr = agentId.value;

    chatStore.addMessage({
      role: 'user', content: text,
      agentId: currentAgentIdStr, timestamp: Date.now(),
      // id is auto-generated by store
    });
    
    isLoadingResponse.value = true;
    const thinkingMessage = `### ${agentDisplayName.value} is processing: "${text.substring(0, 40)}..."\n\n<div class="nerf-spinner-container mx-auto my-4"><div class="nerf-spinner"></div></div>\n\nChecking the knowledge circuits...`;
    chatStore.updateMainContent({
      agentId: currentAgentIdStr, type: 'markdown', data: thinkingMessage,
      title: `${agentDisplayName.value} is on it: ${text.substring(0, 30)}...`,
      timestamp: Date.now()
    });
    chatStore.setMainContentStreaming(true, thinkingMessage);

    try {
      if (!currentSystemPrompt.value) await fetchSystemPrompt();

      let finalSystemPrompt = currentSystemPrompt.value
        .replace(/{{LANGUAGE}}/g, voiceSettingsManager.settings.preferredCodingLanguage || 'english')
        .replace(/{{MODE}}/g, agentConfigRef.value.id) // Use agent ID for mode
        .replace(/{{GENERATE_DIAGRAM}}/g, ((agentConfigRef.value.capabilities?.canGenerateDiagrams && voiceSettingsManager.settings?.generateDiagrams) ?? false).toString())
        .replace(/{{AGENT_CONTEXT_JSON}}/g, JSON.stringify(agentStore.getAgentContext(currentAgentIdStr) || {}))
        .replace(/{{ADDITIONAL_INSTRUCTIONS}}/g, ''); // Nerf usually doesn't need complex additional instructions

      const historyConfig: AdvancedHistoryConfig = {
          ...DEFAULT_NERF_HISTORY_CONFIG,
          maxContextTokens: agentConfigRef.value.capabilities?.maxChatHistory ? agentConfigRef.value.capabilities.maxChatHistory * 120 : DEFAULT_NERF_HISTORY_CONFIG.maxContextTokens, // Example: 120 tokens per message pair for estimation
          simpleRecencyMessageCount: agentConfigRef.value.capabilities?.maxChatHistory || DEFAULT_NERF_HISTORY_CONFIG.simpleRecencyMessageCount,
          numRecentMessagesToPrioritize: agentConfigRef.value.capabilities?.maxChatHistory || DEFAULT_NERF_HISTORY_CONFIG.numRecentMessagesToPrioritize,
      };
      
      const messagesForLlm: ChatMessageFE[] = [];
      messagesForLlm.push({ role: 'system', content: finalSystemPrompt });
      
      const processedHistory = await chatStore.getHistoryForApi(
        currentAgentIdStr, text, finalSystemPrompt, historyConfig
      );
      messagesForLlm.push(...processedHistory.map(m => ({...m, role: m.role as ChatMessageFE['role']})));
      
      // Ensure user message is the last one if not already included by getHistoryForApi's strategy
      if (messagesForLlm[messagesForLlm.length-1]?.content !== text || messagesForLlm[messagesForLlm.length-1]?.role !== 'user') {
         messagesForLlm.push({ role: 'user', content: text, timestamp: Date.now() });
      }
      
      const payload: ChatMessagePayloadFE = {
        messages: messagesForLlm,
        mode: agentConfigRef.value.id,
        language: voiceSettingsManager.settings.preferredCodingLanguage,
        generateDiagram: agentConfigRef.value.capabilities?.canGenerateDiagrams && voiceSettingsManager.settings.generateDiagrams,
        userId: `frontend_user_nerf_${currentAgentIdStr}`,
        conversationId: chatStore.getCurrentConversationId(currentAgentIdStr),
        stream: true,
      };

      let accumulatedContent = "";
      chatStore.clearStreamingMainContent();

      await chatAPI.sendMessageStream(
        payload,
        (chunk: string) => {
          if (chunk) {
            accumulatedContent += chunk;
            chatStore.appendStreamingMainContent(chunk);
            chatStore.updateMainContent({
              agentId: currentAgentIdStr,
              type: agentConfigRef.value.capabilities?.usesCompactRenderer ? 'compact-message-renderer-data' : 'markdown',
              data: accumulatedContent, 
              title: `${agentDisplayName.value}'s response to: "${text.substring(0, 30)}..."`,
              timestamp: Date.now(),
            });
          }
        },
        () => { // onStreamEnd
          isLoadingResponse.value = false; 
          chatStore.setMainContentStreaming(false);
          const finalContent = accumulatedContent.trim();
          if (!finalContent) {
            toast?.add({ type: 'info', title: `${agentDisplayName.value} Says`, message: "Hmm, I didn't find a specific answer for that. Try rephrasing?", duration: 4000 });
             chatStore.updateMainContent({
              agentId: currentAgentIdStr, type: 'markdown',
              data: mainContentToDisplay.value?.data?.replace(/### .*Nerf is processing.*Checking the knowledge circuits.../s, "I'm ready for your next question!") || "How can I help you next?",
              title: `${agentDisplayName.value} Ready`, timestamp: Date.now()
            });
            return;
          }
          chatStore.addMessage({
              role: 'assistant', content: finalContent,
              timestamp: Date.now(), agentId: currentAgentIdStr, 
          });
          // Final update to main content with complete message
          chatStore.updateMainContent({
            agentId: currentAgentIdStr,
            type: agentConfigRef.value.capabilities?.usesCompactRenderer ? 'compact-message-renderer-data' : 'markdown',
            data: finalContent,
            title: `${agentDisplayName.value}'s response to: "${text.substring(0, 30)}..."`,
            timestamp: Date.now(),
          });
        },
        (error: Error) => { 
          console.error(`[${agentDisplayName.value}] Chat stream error:`, error);
          const errorMessage = error.message || 'Nerf ran into a hiccup.';
          toast?.add({ type: 'error', title: `${agentDisplayName.value} Error`, message: errorMessage, duration: 7000 });
          chatStore.addMessage({ role: 'error', content: `Sorry, error: ${errorMessage}`, agentId: currentAgentIdStr, timestamp: Date.now() });
          chatStore.updateMainContent({
            agentId: currentAgentIdStr, type: 'markdown',
            data: `### Nerf Hiccup!\n\n*${errorMessage.replace(/</g, '&lt;').replace(/>/g, '&gt;')}*`,
            title: 'Error', timestamp: Date.now()
          });
          isLoadingResponse.value = false; 
          chatStore.setMainContentStreaming(false);
        }
      );
    } catch (error: any) {
      console.error(`[${agentDisplayName.value}] Chat API setup error:`, error);
      const errorMessage = error.response?.data?.message || error.message || 'Unexpected error with Nerf.';
      toast?.add({ type: 'error', title: `${agentDisplayName.value} Error`, message: errorMessage, duration: 7000 });
      chatStore.addMessage({ role: 'error', content: `Failed response: ${errorMessage}`, agentId: currentAgentIdStr, timestamp: Date.now() });
      chatStore.updateMainContent({
        agentId: currentAgentIdStr, type: 'markdown',
        data: `### Nerf System Error\n\nConnection problem: *${errorMessage.replace(/</g, '&lt;').replace(/>/g, '&gt;')}*`,
        title: 'Connection Error', timestamp: Date.now()
      });
      isLoadingResponse.value = false;
      chatStore.setMainContentStreaming(false);
    }
  };

  const renderMarkdown = (content: string | null): string => {
    if (content === null) return '';
    try {
      return marked.parse(content, { breaks: true, gfm: true }); // Simple config for Nerf
    } catch (e) {
      console.error(`[${agentDisplayName.value}] Markdown parsing error:`, e);
      return `<p style="color: var(--color-error-text);">Error rendering content.</p>`;
    }
  };

  watch(() => agentConfigRef.value?.systemPromptKey, (newKey, oldKey) => {
    if(newKey !== oldKey) fetchSystemPrompt();
  }, { immediate: true });

  return {
    isLoadingResponse,
    currentSystemPrompt, // Mainly for debugging or if view wants to show it
    agentDisplayName,
    mainContentToDisplay,
    initialize,
    cleanup,
    handleNewUserInput,
    renderMarkdown,
  };
}